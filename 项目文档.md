# 表格文件预览与数据可视化中间件技术方案文档

## 目录

- [1. 项目概述](#1-项目概述)
  - [1.1 项目背景](#11-项目背景)
  - [1.2 项目目标](#12-项目目标)
  - [1.3 核心功能](#13-核心功能)
  - [1.4 技术栈概览](#14-技术栈概览)
- [2. 系统架构设计](#2-系统架构设计)
  - [2.1 整体架构](#21-整体架构)
  - [2.2 前后端分离](#22-前后端分离)
  - [2.3 实时通信机制](#23-实时通信机制)
  - [2.4 数据流程](#24-数据流程)
- [3. 前端技术架构](#3-前端技术架构)
  - [3.1 技术栈详情](#31-技术栈详情)
  - [3.2 项目结构](#32-项目结构)
  - [3.3 核心模块](#33-核心模块)
  - [3.4 状态管理](#34-状态管理)
  - [3.5 路由设计](#35-路由设计)
- [4. 后端技术架构](#4-后端技术架构)
  - [4.1 技术栈详情](#41-技术栈详情)
  - [4.2 项目结构](#42-项目结构)
  - [4.3 核心服务](#43-核心服务)
  - [4.4 文件监控机制](#44-文件监控机制)
  - [4.5 文件解析逻辑](#45-文件解析逻辑)
- [5. API规范](#5-api规范)
  - [5.1 基础信息](#51-基础信息)
  - [5.2 RESTful API](#52-restful-api)
    - [5.2.1 文件相关API](#521-文件相关api)
    - [5.2.2 可视化相关API](#522-可视化相关api)
    - [5.2.3 配置相关API](#523-配置相关api)
  - [5.3 WebSocket事件](#53-websocket事件)
- [6. 数据模型](#6-数据模型)
  - [6.1 表格数据模型](#61-表格数据模型)
  - [6.2 可视化配置模型](#62-可视化配置模型)
  - [6.3 系统配置模型](#63-系统配置模型)
  - [6.4 文件信息模型](#64-文件信息模型)
- [7. 部署指南](#7-部署指南)
  - [7.1 环境要求](#71-环境要求)
  - [7.2 前端部署](#72-前端部署)
  - [7.3 后端部署](#73-后端部署)
  - [7.4 配置说明](#74-配置说明)
  - [7.5 Docker部署](#75-docker部署)
- [8. 性能与扩展性](#8-性能与扩展性)
  - [8.1 性能优化方案](#81-性能优化方案)
  - [8.2 扩展性设计](#82-扩展性设计)
  - [8.3 已知限制及解决方案](#83-已知限制及解决方案)
- [9. 安全性考虑](#9-安全性考虑)
  - [9.1 数据安全](#91-数据安全)
  - [9.2 访问控制](#92-访问控制)
  - [9.3 安全最佳实践](#93-安全最佳实践)


## 1. 项目概述

### 1.1 项目背景

作为一种轻量级但功能强大的解决方案，可以帮助用户高效地预览、分析和可视化表格数据。

### 1.2 项目目标


1. **高效文件处理**：提供对CSV、Excel、JSON等常用表格文件格式的高效解析和处理
2. **实时监控**：自动检测和更新文件变化，确保数据的实时性
3. **美观直观的界面**：提供现代化、美观的用户界面，支持响应式设计
4. **强大的数据可视化**：提供丰富的图表类型和交互式配置选项
5. **灵活的配置系统**：支持自定义系统行为，包括文件监控、可视化设置等
6. **跨平台兼容性**：确保在不同设备和系统上的一致体验

### 1.3 核心功能

根据源码分析，本系统实现了以下核心功能：

1. **多格式表格文件预览**
   - 支持CSV、Excel、JSON等多种文件格式
   - 高效处理大型数据集
   - 提供虚拟滚动、排序、过滤等高级表格功能
   - 自动检测数据类型并格式化显示

2. **数据可视化**
   - 支持柱状图、折线图、饼图、散点图等多种图表类型
   - 提供灵活的数据字段映射机制
   - 支持自定义图表配置（标题、颜色、标签等）
   - 可导出和分享可视化视图

3. **实时文件监控**
   - 自动监控指定目录的文件变化
   - 针对新增、更新和删除文件提供实时通知
   - 支持多目录监控和文件类型过滤
   - 自动处理大文件并优化性能

4. **系统配置管理**
   - 提供系统配置的UI界面
   - 支持修改监控目录、文件类型、刷新间隔等
   - 支持主题切换（明亮/暗黑模式）
   - 配置变更实时生效

5. **WebSocket实时通信**
   - 建立前后端实时通信通道
   - 推送文件变化事件
   - 推送配置变化事件
   - 推送可视化配置变化事件

### 1.4 技术栈概览

根据源码分析，本系统采用了现代化的技术栈：

**前端技术栈：**
- **核心框架**：Vue 3（基于Composition API）
- **构建工具**：Vite
- **类型系统**：TypeScript
- **UI框架**：Element Plus（含中文本地化）
- **CSS框架**：TailwindCSS
- **路由管理**：Vue Router
- **状态管理**：Pinia
- **HTTP客户端**：Axios
- **WebSocket客户端**：Socket.io Client
- **数据可视化**：ECharts

**后端技术栈：**
- **运行环境**：Node.js
- **Web框架**：Express
- **类型系统**：TypeScript
- **文件监控**：Chokidar
- **表格解析**：xlsx（Excel）、PapaParse（CSV）
- **WebSocket服务**：Socket.io
- **日志系统**：Morgan + 自定义Logger
- **安全中间件**：Helmet, CORS

## 2. 系统架构设计

### 2.1 整体架构

本系统采用前后端分离的架构设计，通过RESTful API和WebSocket实现前后端通信。整体架构如下图所示：

```
┌───────────────────┐      ┌───────────────────┐
│                   │      │                   │
│    客户端浏览器    │◄────►│    前端应用        │
│                   │      │    (Vue 3)        │
└───────────────────┘      └─────────┬─────────┘
                                    │
                                    │ HTTP/WebSocket
                                    │
                           ┌────────▼──────────┐
                           │                   │
                           │    后端服务        │
                           │    (Node.js)      │
                           └────────┬──────────┘
                                    │
                                    │ 文件系统访问
                                    │
                           ┌────────▼──────────┐
                           │                   │
                           │    表格文件        │
                           │                   │
                           └───────────────────┘
```

系统主要由以下三部分组成：

1. **前端应用**：基于Vue 3开发的单页面应用，负责用户界面展示和交互逻辑
2. **后端服务**：基于Node.js和Express开发的Web服务，处理文件监控、解析和数据处理
3. **文件系统**：存储表格文件的物理位置，由后端服务监控和读取

### 2.2 前后端分离

系统采用完全的前后端分离架构，实现了关注点分离原则：

1. **前端职责**：
   - 用户界面渲染和交互
   - 数据可视化处理
   - 状态管理
   - 与后端的HTTP通信
   - WebSocket连接管理
   - 主题和样式管理

2. **后端职责**：
   - 文件系统监控
   - 表格文件解析
   - 数据处理和转换
   - API服务提供
   - WebSocket服务提供
   - 配置管理

这种分离使得前后端团队能够独立开发和部署，提高了开发效率和系统的可维护性。

### 2.3 实时通信机制

本系统使用WebSocket实现前后端的实时通信，主要通过Socket.io库实现。实时通信的主要场景包括：

1. **文件变化通知**：当监控目录中的文件发生变化（新增、修改、删除）时，后端会通过WebSocket向前端推送变更通知
2. **配置变更通知**：当系统配置被更新时，后端会通过WebSocket向所有连接的客户端推送新的配置
3. **可视化配置变更通知**：当某个文件的可视化配置发生变化时，后端会通过WebSocket通知前端更新图表

WebSocket连接建立流程：

```
前端                                    后端
  │                                      │
  │  1. 初始化连接请求                    │
  │ ─────────────────────────────────>   │
  │                                      │
  │  2. 连接确认                          │
  │ <─────────────────────────────────   │
  │                                      │
  │  3. 注册事件监听器                    │
  │                                      │
  │  4. 开始接收实时事件                   │
  │ <─────────────────────────────────   │
  │                                      │
```

系统使用了Socket.io的重连机制，确保网络波动时的连接稳定性。

### 2.4 数据流程

系统的主要数据流程如下：

1. **文件监控与更新流程**：

```
文件变化 → 后端检测 → 文件解析 → 数据处理 → WebSocket通知 → 前端更新 → 表格渲染/可视化
```

详细步骤：
- 文件系统中的文件发生变化（新增、修改、删除）
- 后端文件监控服务（基于Chokidar）检测到变化并触发事件
- 文件解析服务根据文件类型（CSV、Excel、JSON）读取并解析文件内容
- 数据处理服务进行必要的转换和格式化
- WebSocket服务向前端推送变更通知
- 前端接收通知并更新相关UI组件
- 表格组件和可视化组件重新渲染数据

2. **用户配置更新流程**：

```
用户修改配置 → 前端API请求 → 后端保存配置 → 应用新配置 → WebSocket通知 → 前端更新UI
```

详细步骤：
- 用户通过配置界面修改系统设置
- 前端通过RESTful API将新配置提交到后端
- 后端验证并保存新配置
- 后端应用新配置（如调整文件监控设置）
- WebSocket服务向所有连接的客户端推送配置变更通知
- 前端接收通知并更新相关UI组件

3. **可视化配置流程**：

```
用户配置可视化 → 前端API请求 → 后端保存配置 → WebSocket通知 → 前端更新图表
```

详细步骤：
- 用户通过可视化配置界面设置图表类型和数据映射
- 前端通过RESTful API将新的可视化配置提交到后端
- 后端保存可视化配置
- WebSocket服务向相关客户端推送可视化配置变更通知
- 前端接收通知并更新图表展示

## 3. 前端技术架构

### 3.1 技术栈详情

根据源码分析，前端使用了现代化的技术栈，主要包括：

1. **核心框架**: Vue 3
   - 使用Composition API作为主要的组件编写方式
   - 利用响应式系统实现高效的状态管理和UI更新

2. **构建工具**: Vite
   - 提供快速的开发服务器和优化的生产构建
   - ES模块导入实现开发时的即时模块热更新

3. **类型系统**: TypeScript
   - 为整个应用提供静态类型检查
   - 增强代码可维护性和自文档化

4. **UI框架**: Element Plus
   - 提供丰富的UI组件库
   - 集成中文本地化支持
   - 包含表格、表单、对话框等组件

5. **CSS框架**: TailwindCSS
   - 提供实用优先的CSS工具类
   - 自定义主题和响应式设计支持

6. **路由管理**: Vue Router
   - 为SPA应用提供路由管理
   - 支持路由懒加载和导航守卫

7. **状态管理**: Pinia
   - 替代Vuex的新一代状态管理库
   - 与Vue 3和TypeScript集成性更好

8. **HTTP客户端**: Axios
   - 提供基于Promise的HTTP客户端
   - 支持请求/响应拦截和错误处理

9. **WebSocket客户端**: Socket.io Client
   - 与后端Socket.io服务器建立实时通信
   - 提供自动重连和事件管理

10. **数据可视化**: ECharts
    - 提供丰富的图表类型
    - 支持响应式和交互式可视化

### 3.2 项目结构

前端项目采用功能模块化的目录结构，根据源码分析如下：

```
frontend/
├── public/               # 静态资源目录
├── src/                  # 源代码目录
│   ├── assets/           # 静态资源（图片、样式等）
│   │   ├── common/       # 通用组件
│   │   ├── table/        # 表格相关组件
│   │   └── visualization/ # 可视化相关组件
│   ├── layouts/          # 布局组件
│   ├── views/            # 页面组件
│   │   ├── files/        # 文件浏览页面
│   │   ├── table/        # 表格查看页面
│   │   ├── visualization/ # 数据可视化页面
│   │   └── settings/     # 系统设置页面
│   ├── router/           # 路由配置
│   ├── stores/           # Pinia状态管理
│   ├── services/         # 服务层（API、WebSocket等）
│   ├── types/            # TypeScript类型定义
│   ├── utils/            # 工具函数
│   ├── App.vue           # 根组件
│   └── main.ts           # 应用入口
├── index.html            # HTML模板
├── vite.config.ts        # Vite配置
├── tsconfig.json         # TypeScript配置
├── package.json          # 依赖配置
└── tailwind.config.js    # TailwindCSS配置
```

### 3.3 核心模块

前端应用由以下核心模块组成：

1. **文件浏览模块**
   - 展示监控目录中的文件列表
   - 支持文件类型筛选和目录导航
   - 提供文件预览入口
   - 实现文件上传功能

   关键组件：
   ```
   views/files/Index.vue         # 文件浏览页面
   components/file/FileList.vue  # 文件列表组件
   components/file/FileUpload.vue # 文件上传组件
   ```

2. **表格预览模块**
   - 高效渲染表格数据
   - 实现虚拟滚动，优化大数据集渲染
   - 提供排序、筛选、搜索功能
   - 支持列宽调整和分页

   关键组件：
   ```
   views/table/Index.vue         # 表格查看页面
   components/table/TableViewer.vue # 表格查看组件
   components/table/VirtualTable.vue # 虚拟滚动表格
   components/table/TableToolbar.vue # 表格工具栏
   ```

3. **数据可视化模块**
   - 提供多种图表类型
   - 支持图表配置和数据映射
   - 实现图表交互和导出
   - 可视化配置保存和共享

   关键组件：
   ```
   views/visualization/Index.vue  # 可视化页面
   components/visualization/ChartContainer.vue # 图表容器
   components/visualization/ChartConfig.vue # 图表配置
   components/visualization/DataMapper.vue # 数据映射
   ```

4. **系统设置模块**
   - 提供配置界面
   - 支持修改监控目录、文件类型等
   - 实现主题切换
   - 管理系统行为

   关键组件：
   ```
   views/settings/Index.vue      # 设置页面
   components/settings/ConfigPanel.vue # 配置面板
   components/settings/ThemeSelector.vue # 主题选择器
   ```

5. **通信服务模块**
   - 封装API请求
   - 管理WebSocket连接
   - 处理实时事件
   - 提供错误处理

   关键文件：
   ```
   services/api.ts        # API服务
   services/websocket.ts  # WebSocket服务
   ```

### 3.4 状态管理

前端使用Pinia进行状态管理，主要包括以下几个核心状态仓库：

1. **配置状态仓库 (configStore)**
   - 管理全局系统配置
   - 处理主题切换逻辑
   - 提供配置更新方法
   - 实现配置持久化

   核心功能：
   ```typescript
   // 状态定义
   const state = () => ({
     config: null as SystemConfig | null,
     theme: 'light' as 'light' | 'dark' | 'auto',
     // 其他配置项...
   });

   // 操作方法
   const actions = {
     async fetchConfig() {/* 从后端获取配置 */},
     async updateConfig(config: SystemConfig) {/* 更新配置 */},
     handleConfigChange(config: SystemConfig) {/* 处理配置变更 */},
     toggleTheme() {/* 切换主题 */}
   };
   ```

2. **文件状态仓库 (fileStore)**
   - 管理文件列表状态
   - 处理文件变更逻辑
   - 提供文件操作方法
   - 管理当前选中文件

   核心功能：
   ```typescript
   // 状态定义
   const state = () => ({
     files: [] as FileInfo[],
     currentDirectory: '',
     selectedFileId: null as string | null,
     // 其他文件相关状态...
   });

   // 操作方法
   const actions = {
     async fetchFiles(path?: string) {/* 获取文件列表 */},
     handleFileChange(event: FileChangeEvent) {/* 处理文件变更 */},
     selectFile(fileId: string) {/* 选择文件 */}
   };
   ```

3. **表格数据仓库 (tableStore)**
   - 管理当前表格数据
   - 提供数据处理方法
   - 管理表格视图状态
   - 缓存表格数据

   核心功能：
   ```typescript
   // 状态定义
   const state = () => ({
     tableData: null as TableData | null,
     sortBy: '',
     sortDirection: 'asc' as 'asc' | 'desc',
     filters: {} as Record<string, any>,
     // 其他表格状态...
   });

   // 操作方法
   const actions = {
     async fetchTableData(fileId: string) {/* 获取表格数据 */},
     sortData(column: string) {/* 排序数据 */},
     filterData(filters: Record<string, any>) {/* 筛选数据 */}
   };
   ```

4. **可视化状态仓库 (visualizationStore)**
   - 管理可视化配置
   - 提供图表操作方法
   - 处理可视化配置变更
   - 管理当前选中图表

   核心功能：
   ```typescript
   // 状态定义
   const state = () => ({
     visualizations: [] as VisualizationConfig[],
     selectedVisualization: null as VisualizationConfig | null,
     // 其他可视化状态...
   });

   // 操作方法
   const actions = {
     async fetchVisualizations(fileId: string) {/* 获取可视化配置 */},
     async saveVisualization(config: VisualizationConfig) {/* 保存可视化配置 */},
     handleVisualizationChange(event: VisualizationChangeEvent) {/* 处理可视化变更 */}
   };
   ```

### 3.5 路由设计

前端应用使用Vue Router进行路由管理，根据源码分析主要定义了以下路由：

```typescript
const routes: Array<RouteRecordRaw> = [
  {
    path: '/',
    name: 'Home',
    component: () => import('@/views/Home.vue'),
    meta: {
      title: '首页',
      requiresAuth: false,
    },
  },
  {
    path: '/files',
    name: 'Files',
    component: () => import('@/views/files/Index.vue'),
    meta: {
      title: '文件浏览',
      requiresAuth: false,
    },
  },
  {
    path: '/table/:id',
    name: 'TableView',
    component: () => import('@/views/table/Index.vue'),
    props: true,
    meta: {
      title: '表格查看',
      requiresAuth: false,
    },
  },
  {
    path: '/visualization/:fileId',
    name: 'Visualization',
    component: () => import('@/views/visualization/Index.vue'),
    props: true,
    meta: {
      title: '数据可视化',
      requiresAuth: false,
    },
    children: [
      {
        path: ':visId',
        name: 'VisualizationDetail',
        component: () => import('@/views/visualization/Detail.vue'),
        props: true,
        meta: {
          title: '可视化详情',
          requiresAuth: false,
        },
      },
    ],
  },
  {
    path: '/settings',
    name: 'Settings',
    component: () => import('@/views/settings/Index.vue'),
    meta: {
      title: '系统设置',
      requiresAuth: false,
    },
  },
  {
    path: '/:pathMatch(.*)*',
    name: 'NotFound',
    component: () => import('@/views/NotFound.vue'),
    meta: {
      title: '页面未找到',
      requiresAuth: false,
    },
  },
];
```

路由设计特点：

1. **懒加载**：所有路由组件都使用动态导入，实现按需加载
2. **路由参数**：使用路由参数传递文件ID和可视化配置ID
3. **嵌套路由**：可视化详情使用嵌套路由实现
4. **路由元数据**：为每个路由添加元数据，如标题和认证要求
5. **404处理**：使用通配符路径捕获所有未定义路由

此外，应用实现了路由守卫，在路由切换时设置页面标题：

```typescript
router.beforeEach((to, from, next) => {
  // 设置页面标题
  document.title = `${to.meta.title || '表格文件预览与数据可视化'} - 表格文件预览与数据可视化中间件`;
  next();
});
```

用户导航流程：

1. 首页 → 文件浏览页
2. 文件浏览页 → 选择文件 → 表格查看页
3. 表格查看页 → 数据可视化页
4. 任意页面 → 系统设置页

## 4. 后端技术架构

### 4.1 技术栈详情

后端采用Node.js环境，基于Express框架构建，主要技术组件包括：

1. **运行环境**: Node.js
   - 提供JavaScript运行环境
   - 利用事件驱动、非阻塞I/O模型
   - 适合I/O密集型应用如文件监控

2. **Web框架**: Express
   - 提供HTTP服务和路由管理
   - 中间件机制处理请求和响应
   - RESTful API设计支持

3. **类型系统**: TypeScript
   - 为后端代码提供静态类型检查
   - 增强代码可读性和可维护性
   - 与前端共享类型定义

4. **文件监控**: Chokidar
   - 高效监控文件系统变化
   - 处理文件添加、修改、删除事件
   - 支持配置监控目录和文件类型

5. **文件解析**:
   - xlsx (SheetJS): 处理Excel文件解析
   - PapaParse: 处理CSV文件解析
   - JSON: 原生支持JSON文件解析

6. **WebSocket服务**: Socket.io
   - 建立实时双向通信通道
   - 提供自动重连和事件管理
   - 支持发布/订阅模式

7. **安全中间件**:
   - Helmet: 设置安全相关HTTP头
   - CORS: 配置跨域资源共享

8. **日志系统**:
   - Morgan: HTTP请求日志记录
   - 自定义Logger: 应用程序日志管理

9. **文件处理**:
   - Multer: 处理文件上传
   - fs/promises: 异步文件系统操作

10. **环境配置**:
    - dotenv: 环境变量管理
    - 配置文件加载和验证

### 4.2 项目结构

后端项目采用模块化设计，根据源码分析得到以下目录结构：

```
backend/
├── data/                  # 数据存储目录
├── uploads/               # 文件上传目录
├── logs/                  # 日志文件目录
├── config/                # 配置文件目录
├── src/                   # 源代码目录
│   ├── controllers/       # 控制器目录
│   │   ├── FileController.ts       # 文件控制器
│   │   ├── ConfigController.ts     # 配置控制器
│   │   ├── VisualizationController.ts # 可视化控制器
│   │   └── WebSocketController.ts  # WebSocket控制器
│   ├── routes/            # 路由目录
│   │   ├── index.ts       # 主路由
│   │   ├── files.ts       # 文件路由
│   │   └── config.ts      # 配置路由
│   ├── services/          # 服务目录
│   │   ├── FileWatcherService.ts   # 文件监控服务
│   │   ├── FileParserService.ts    # 文件解析服务
│   │   ├── ConfigService.ts        # 配置服务
│   │   └── VisualizationService.ts # 可视化服务
│   ├── models/            # 数据模型目录
│   │   ├── index.ts       # 模型导出
│   │   ├── TableData.ts   # 表格数据模型
│   │   └── SystemConfig.ts # 系统配置模型
│   ├── utils/             # 工具函数目录
│   │   ├── fileUtils.ts   # 文件工具函数
│   │   ├── responseUtils.ts # 响应工具函数
│   │   └── logger.ts      # 日志工具
│   ├── app.ts             # Express应用配置
│   └── index.ts           # 应用入口
├── dist/                  # 编译输出目录
├── .env                   # 环境变量文件
├── tsconfig.json          # TypeScript配置
└── package.json           # 依赖配置
```

### 4.3 核心服务

后端包含以下几个核心服务模块：

1. **文件监控服务 (FileWatcherService)**
   - 监控指定目录的文件变化
   - 触发文件变化事件
   - 管理监控配置
   
   核心实现：
   ```typescript
   class FileWatcherService {
     private watchers: chokidar.FSWatcher[] = [];
     private eventListeners: { [key: string]: Array<(data: any) => void> } = {};
     
     // 初始化文件监控
     private async init() {
       // 加载配置并启动监控
     }
     
     // 启动文件监控
     private async startWatchers() {
       const { directories, fileTypes } = this.config.fileWatching;
       
       // 创建Chokidar监控实例
       const watcher = chokidar.watch(directories, { /*配置*/ });
       
       // 注册事件监听器
       watcher.on('add', (filePath) => {
         if (this.isWatchedFileType(filePath, fileTypes)) {
           this.emit('file-change', { type: 'add', path: filePath });
         }
       });
       
       // 其他事件处理...
     }
     
     // 注册事件处理
     public on(event: string, callback: (data: any) => void) {
       // 注册事件回调
     }
   }
   ```

2. **文件解析服务 (FileParserService)**
   - 根据文件类型解析表格数据
   - 处理CSV、Excel、JSON格式
   - 生成统一的数据结构
   
   核心实现：
   ```typescript
   class FileParserService {
     // 解析文件主入口
     public async parseFile(filePath: string): Promise<TableData> {
       const ext = fileUtils.getFileExtension(filePath);
       
       // 根据扩展名选择解析器
       switch (ext) {
         case '.csv':
           return await this.parseCSV(filePath);
         case '.xlsx':
         case '.xls':
           return await this.parseExcel(filePath);
         case '.json':
           return await this.parseJSON(filePath);
         default:
           throw new Error(`不支持的文件类型: ${ext}`);
       }
     }
     
     // CSV解析实现
     private async parseCSV(filePath: string): Promise<TableData> {
       // 使用PapaParse解析CSV
     }
     
     // Excel解析实现
     private async parseExcel(filePath: string): Promise<TableData> {
       // 使用SheetJS解析Excel
     }
     
     // JSON解析实现
     private async parseJSON(filePath: string): Promise<TableData> {
       // 解析JSON文件
     }
   }
   ```

3. **配置服务 (ConfigService)**
   - 管理系统配置
   - 提供配置读写接口
   - 触发配置变更事件
   
   核心实现：
   ```typescript
   class ConfigService {
     private config: SystemConfig;
     private eventListeners: { [key: string]: Array<(data: any) => void> } = {};
     
     // 获取配置
     public async getConfig(): Promise<SystemConfig> {
       // 返回当前配置或从文件加载
     }
     
     // 更新配置
     public async updateConfig(newConfig: SystemConfig): Promise<SystemConfig> {
       // 验证并保存新配置
       // 触发配置变更事件
     }
     
     // 事件处理
     public on(event: string, callback: (data: any) => void) {
       // 注册事件回调
     }
   }
   ```

4. **可视化服务 (VisualizationService)**
   - 管理可视化配置
   - 提供配置读写接口
   - 触发可视化配置变更事件
   
   核心实现：
   ```typescript
   class VisualizationService {
     // 获取可视化配置
     public async getVisualizations(fileId: string): Promise<VisualizationConfig[]> {
       // 获取指定文件的可视化配置
     }
     
     // 创建可视化配置
     public async createVisualization(fileId: string, config: Omit<VisualizationConfig, 'id'>): Promise<VisualizationConfig> {
       // 创建新的可视化配置
       // 触发可视化配置变更事件
     }
     
     // 更新可视化配置
     public async updateVisualization(fileId: string, visId: string, config: Omit<VisualizationConfig, 'id'>): Promise<VisualizationConfig> {
       // 更新指定的可视化配置
       // 触发可视化配置变更事件
     }
   }
   ```

5. **WebSocket控制器 (WebSocketController)**
   - 管理WebSocket连接
   - 处理事件转发
   - 维护客户端会话
   
   核心实现：
   ```typescript
   class WebSocketController {
     private io: Server | null = null;
     
     // 初始化WebSocket服务
     public init(server: http.Server) {
       this.io = new Server(server, { /*配置*/ });
       
       // 处理连接事件
       this.io.on('connection', (socket: Socket) => {
         // 处理连接和断开
       });
       
       // 设置事件监听
       this.setupFileChangeListener();
       this.setupConfigChangeListener();
       this.setupVisualizationChangeListener();
     }
     
     // 设置文件变化监听
     private setupFileChangeListener() {
       fileWatcherService.on('file-change', (data) => {
         // 广播文件变化事件
         this.io?.emit('file-change', data);
       });
     }
     
     // 其他事件监听设置...
   }
   ```

### 4.4 文件监控机制

文件监控是系统的核心功能之一，通过Chokidar库实现高效的文件系统监控：

1. **监控配置**
   - 支持配置监控目录（多目录）
   - 支持过滤监控的文件类型
   - 可配置监控敏感度和稳定阈值

2. **事件处理**
   - `add`: 处理文件新增事件
   - `change`: 处理文件修改事件
   - `unlink`: 处理文件删除事件
   - `error`: 处理监控错误事件

3. **性能优化**
   - 使用`awaitWriteFinish`选项避免文件写入过程中的部分读取
   - 实现文件过滤，只处理关注的文件类型
   - 优化处理大文件和高频变更情况

4. **配置动态调整**
   - 监听系统配置变更
   - 支持热重载监控配置
   - 可动态调整监控目录和文件类型

监控流程图：

```
系统配置 ──────────────────────────┐
                                 │
                                 ▼
文件系统 ───► Chokidar监控 ───► 事件触发 ───► 文件解析 ───► 事件通知
                   ▲                                       │
                   │                                       │
                   └───────────────────────────────────────┘
                          配置变更导致监控重启
```

### 4.5 文件解析逻辑

文件解析服务负责将不同格式的表格文件转换为统一的数据结构：

1. **支持的文件格式**
   - CSV文件 (.csv)：使用PapaParse库解析
   - Excel文件 (.xlsx, .xls)：使用SheetJS库解析
   - JSON文件 (.json)：使用原生JSON解析

2. **解析流程**
   - 文件类型识别：根据文件扩展名选择对应解析器
   - 文件读取：异步读取文件内容
   - 内容解析：调用对应库解析原始内容
   - 数据转换：将解析结果转换为统一的TableData结构
   - 元数据添加：补充文件名、大小、修改时间等元数据

3. **数据类型处理**
   - 自动识别数字、字符串、日期等数据类型
   - 根据内容智能推断列类型
   - 保持原始格式信息

4. **大文件处理**
   - 对于大型文件采用流式处理
   - 实现分块读取和解析
   - 优化内存使用

解析示例（CSV文件）：

```typescript
private async parseCSV(filePath: string): Promise<TableData> {
  try {
    // 读取文件内容
    const fileContent = await fileUtils.readFileAsync(filePath, 'utf8');
    
    // 使用PapaParse解析CSV
    const result = Papa.parse(fileContent, {
      header: true,           // 第一行作为表头
      dynamicTyping: true,    // 自动类型转换
      skipEmptyLines: true    // 跳过空行
    });
    
    // 转换为应用数据结构
    const parsedData = result.data as Record<string, any>[];
    const headers = this.generateHeaders(parsedData[0]);
    
    return {
      headers,
      rows: parsedData,
      metadata: {
        fileName: path.basename(filePath),
        fileType: 'csv',
        lastModified: new Date(),
        rowCount: parsedData.length
      }
    };
  } catch (err) {
    logger.error(`解析CSV文件失败: ${filePath}`, err);
    throw err;
  }
}
```

## 5. API规范

### 5.1 基础信息

本系统提供RESTful API和WebSocket事件两种通信机制，以实现前后端数据交互和实时通知。

**基础信息：**
- **Base URL**: `/api`
- **认证方式**: 当前版本无需认证（可扩展）
- **内容类型**: JSON (application/json)
- **字符编码**: UTF-8

**通用响应格式**:
```json
{
  "code": 200,          // 状态码：2xx成功，4xx客户端错误，5xx服务器错误
  "message": "操作成功",  // 状态描述
  "data": {}            // 响应数据（对象、数组或null）
}
```

**错误处理**:
- 遵循HTTP状态码语义
- 提供详细错误信息
- 使用统一的错误响应格式

**API版本控制**:
- 当前默认为v1，未在URL中显式指定
- 未来版本可通过URL路径(/api/v2/...)或Accept头部指定

### 5.2 RESTful API

根据后端源码分析，系统提供以下RESTful API端点：

#### 5.2.1 文件相关API

1. **获取文件列表**

   获取指定目录下的所有文件和子目录。

   - **URL**: `/api/files`
   - **方法**: `GET`
   - **URL参数**:
     - `path=[string]` (可选): 要列出内容的目录路径，默认为配置的数据目录
     - `includeSubdirectories=[boolean]` (可选): 是否包含子目录，默认为true

   - **成功响应**:
   ```json
   {
     "code": 200,
     "message": "操作成功",
     "data": [
       {
         "id": "L3VwbG9hZHMvc2FtcGxlLmNzdg==",  // Base64编码的文件路径
         "name": "sample.csv",
         "path": "/uploads/sample.csv",
         "type": "csv",
         "size": 1024,
         "lastModified": "2023-04-25T15:39:27.892Z",
         "isDirectory": false
       },
       {
         "id": "L3VwbG9hZHMvZGF0YQ==",
         "name": "data",
         "path": "/uploads/data",
         "type": "directory",
         "size": 0,
         "lastModified": "2023-04-25T15:30:00.000Z",
         "isDirectory": true
       }
     ]
   }
   ```

2. **获取文件内容**

   获取指定文件的解析后数据。

   - **URL**: `/api/files/:id/content`
   - **方法**: `GET`
   - **URL参数**:
     - `id=[string]`: 文件ID (Base64编码的文件路径)

   - **成功响应**:
   ```json
   {
     "code": 200,
     "message": "操作成功",
     "data": {
       "headers": [
         {
           "key": "name",
           "label": "name",
           "type": "string",
           "sortable": true,
           "filterable": true
         },
         {
           "key": "age",
           "label": "age",
           "type": "number",
           "sortable": true,
           "filterable": true
         }
       ],
       "rows": [
         { "name": "张三", "age": 30 },
         { "name": "李四", "age": 25 }
       ],
       "metadata": {
         "fileName": "sample.csv",
         "fileType": "csv",
         "lastModified": "2023-04-25T15:39:27.892Z",
         "rowCount": 2,
         "filePath": "/uploads/sample.csv",
         "fileSize": 1024
       }
     }
   }
   ```

3. **上传文件**

   上传一个新文件到服务器。

   - **URL**: `/api/files/upload`
   - **方法**: `POST`
   - **Content-Type**: `multipart/form-data`
   - **请求参数**:
     - `file`: 要上传的文件

   - **成功响应**:
   ```json
   {
     "code": 201,
     "message": "文件上传成功",
     "data": {
       "id": "L3VwbG9hZHMvc2FtcGxlLWFiYzEyMy5jc3Y=",
       "name": "sample-abc123.csv",
       "path": "/uploads/sample-abc123.csv",
       "type": "csv",
       "size": 1024,
       "lastModified": "2023-04-25T15:45:00.000Z",
       "isDirectory": false
     }
   }
   ```

   - **错误响应**:
   ```json
   {
     "code": 400,
     "message": "未提供文件",
     "data": null
   }
   ```

#### 5.2.2 可视化相关API

1. **获取可视化配置**

   获取指定文件的所有可视化配置。

   - **URL**: `/api/files/:id/visualizations`
   - **方法**: `GET`
   - **URL参数**:
     - `id=[string]`: 文件ID (Base64编码的文件路径)

   - **成功响应**:
   ```json
   {
     "code": 200,
     "message": "操作成功",
     "data": [
       {
         "id": "vis-123456",
         "name": "年龄分布图",
         "type": "bar",
         "dataMapping": {
           "x": "name",
           "y": "age"
         },
         "options": {
           "title": "用户年龄分布",
           "xAxisLabel": "姓名",
           "yAxisLabel": "年龄"
         }
       }
     ]
   }
   ```

2. **创建可视化配置**

   为指定文件创建新的可视化配置。

   - **URL**: `/api/files/:id/visualizations`
   - **方法**: `POST`
   - **URL参数**:
     - `id=[string]`: 文件ID (Base64编码的文件路径)
   - **请求体**:
   ```json
   {
     "name": "收入分布图",
     "type": "pie",
     "dataMapping": {
       "x": "category",
       "y": "value"
     },
     "options": {
       "title": "收入分类统计",
       "legend": true
     }
   }
   ```

   - **成功响应**:
   ```json
   {
     "code": 201,
     "message": "可视化配置已创建",
     "data": {
       "id": "vis-789012",
       "name": "收入分布图",
       "type": "pie",
       "dataMapping": {
         "x": "category",
         "y": "value"
       },
       "options": {
         "title": "收入分类统计",
         "legend": true
       }
     }
   }
   ```

3. **更新可视化配置**

   更新指定文件的特定可视化配置。

   - **URL**: `/api/files/:id/visualizations/:visId`
   - **方法**: `PUT`
   - **URL参数**:
     - `id=[string]`: 文件ID (Base64编码的文件路径)
     - `visId=[string]`: 可视化配置ID
   - **请求体**:
   ```json
   {
     "name": "收入分布图（更新版）",
     "type": "pie",
     "dataMapping": {
       "x": "category",
       "y": "value"
     },
     "options": {
       "title": "收入分类统计",
       "legend": true,
       "theme": "dark"
     }
   }
   ```

   - **成功响应**:
   ```json
   {
     "code": 200,
     "message": "可视化配置已更新",
     "data": {
       "id": "vis-789012",
       "name": "收入分布图（更新版）",
       "type": "pie",
       "dataMapping": {
         "x": "category",
         "y": "value"
       },
       "options": {
         "title": "收入分类统计",
         "legend": true,
         "theme": "dark"
       }
     }
   }
   ```

4. **删除可视化配置**

   删除指定文件的特定可视化配置。

   - **URL**: `/api/files/:id/visualizations/:visId`
   - **方法**: `DELETE`
   - **URL参数**:
     - `id=[string]`: 文件ID (Base64编码的文件路径)
     - `visId=[string]`: 可视化配置ID

   - **成功响应**:
   ```json
   {
     "code": 200,
     "message": "可视化配置已删除",
     "data": null
   }
   ```

#### 5.2.3 配置相关API

1. **获取系统配置**

   获取当前系统配置。

   - **URL**: `/api/config`
   - **方法**: `GET`

   - **成功响应**:
   ```json
   {
     "code": 200,
     "message": "操作成功",
     "data": {
       "fileWatching": {
         "directories": ["./data", "./uploads"],
         "fileTypes": [".csv", ".xlsx", ".json"],
         "watchInterval": 5000
       },
       "visualization": {
         "defaultChartType": "bar",
         "colorScheme": "default",
         "autoRefresh": true,
         "refreshInterval": 30000
       },
       "ui": {
         "theme": "light",
         "language": "zh-CN",
         "tableSettings": {
           "pageSize": 50,
           "enableSearch": true
         }
       }
     }
   }
   ```

2. **更新系统配置**

   更新系统配置。

   - **URL**: `/api/config`
   - **方法**: `PUT`
   - **请求体**:
   ```json
   {
     "fileWatching": {
       "directories": ["./data", "./uploads", "./custom"],
       "fileTypes": [".csv", ".xlsx", ".json"],
       "watchInterval": 10000
     },
     "visualization": {
       "defaultChartType": "line",
       "colorScheme": "dark",
       "autoRefresh": true,
       "refreshInterval": 60000
     },
     "ui": {
       "theme": "dark",
       "language": "zh-CN",
       "tableSettings": {
         "pageSize": 100,
         "enableSearch": true
       }
     }
   }
   ```

   - **成功响应**:
   ```json
   {
     "code": 200,
     "message": "配置已更新",
     "data": {
       "fileWatching": {
         "directories": ["./data", "./uploads", "./custom"],
         "fileTypes": [".csv", ".xlsx", ".json"],
         "watchInterval": 10000
       },
       "visualization": {
         "defaultChartType": "line",
         "colorScheme": "dark",
         "autoRefresh": true,
         "refreshInterval": 60000
       },
       "ui": {
         "theme": "dark",
         "language": "zh-CN",
         "tableSettings": {
           "pageSize": 100,
           "enableSearch": true
         }
       }
     }
   }
   ```

### 5.3 WebSocket事件

系统使用Socket.io实现WebSocket通信，提供以下实时事件：

1. **建立连接**

   WebSocket服务通过Socket.io提供，客户端可以使用以下配置连接：

   ```javascript
   const socket = io({
     path: '/socket.io',
     autoConnect: true,
     reconnection: true,
     reconnectionAttempts: 10,
     reconnectionDelay: 3000
   });
   ```

2. **文件变化事件 (file-change)**

   当监控目录中的文件发生变化时，服务器会推送此事件。

   **事件数据格式**:
   ```json
   {
     "type": "add|change|unlink",  // 变化类型：新增、修改、删除
     "path": "/uploads/sample.csv", // 文件路径
     "timestamp": "2023-04-25T15:50:00.000Z" // 变化时间
   }
   ```

   **客户端监听示例**:
   ```javascript
   socket.on('file-change', (data) => {
     console.log('文件变化:', data);
     if (data.type === 'add') {
       // 处理文件新增
     } else if (data.type === 'change') {
       // 处理文件修改
     } else if (data.type === 'unlink') {
       // 处理文件删除
     }
   });
   ```

3. **配置变化事件 (config-change)**

   当系统配置被更新时，服务器会推送此事件。

   **事件数据格式**:
   ```json
   {
     "timestamp": "2023-04-25T15:55:00.000Z",
     "config": {
       // 完整的系统配置对象
     }
   }
   ```

   **客户端监听示例**:
   ```javascript
   socket.on('config-change', (data) => {
     console.log('配置变化:', data);
     // 更新本地配置缓存
     // 根据新配置调整UI
   });
   ```

4. **可视化配置变化事件 (visualization-change)**

   当文件的可视化配置发生变化时，服务器会推送此事件。

   **事件数据格式**:
   ```json
   {
     "type": "create|update|delete",  // 变化类型：创建、更新、删除
     "fileId": "L3VwbG9hZHMvc2FtcGxlLmNzdg==", // 文件ID
     "visualizationId": "vis-123456",  // 可视化配置ID（仅用于更新和删除）
     "timestamp": "2023-04-25T16:00:00.000Z", // 变化时间
     "config": {
       // 仅用于创建和更新事件
       // 完整的可视化配置对象
     }
   }
   ```

   **客户端监听示例**:
   ```javascript
   socket.on('visualization-change', (data) => {
     console.log('可视化配置变化:', data);
     if (data.type === 'create') {
       // 处理新增配置
     } else if (data.type === 'update') {
       // 处理更新配置
     } else if (data.type === 'delete') {
       // 处理删除配置
     }
   });
   ```

## 6. 数据模型

### 6.1 表格数据模型

表格数据模型是系统的核心数据结构之一，用于统一表示不同格式（CSV、Excel、JSON）的表格数据。根据源码分析，表格数据模型定义如下：

```typescript
interface TableData {
  headers: Array<TableHeader>; // 表头信息
  rows: Array<Record<string, any>>; // 数据行
  metadata: TableMetadata; // 元数据
}

interface TableHeader {
  key: string;       // 列标识，用于数据访问
  label: string;     // 列显示名称
  type: 'string' | 'number' | 'date' | 'boolean'; // 数据类型
  width?: number;    // 列宽度（可选）
  sortable?: boolean; // 是否可排序（可选）
  filterable?: boolean; // 是否可筛选（可选）
}

interface TableMetadata {
  fileName: string;   // 文件名
  fileType: string;   // 文件类型（csv, excel, json等）
  lastModified: Date; // 最后修改时间
  rowCount: number;   // 行数
  filePath?: string;  // 文件路径（可选）
  fileSize?: number;  // 文件大小（可选）
}
```

**主要特点**：
- 使用统一的结构表示不同来源的表格数据
- 数据类型自动推断和标准化
- 提供丰富的元数据支持表格展示
- 支持UI交互所需的排序和筛选标记

### 6.2 可视化配置模型

可视化配置模型用于定义表格数据如何映射到可视化图表。根据源码分析，可视化配置模型定义如下：

```typescript
interface VisualizationConfig {
  id?: string;       // 配置ID（服务端生成）
  name: string;      // 配置名称
  type: 'bar' | 'line' | 'pie' | 'scatter' | 'custom'; // 图表类型
  dataMapping: {     // 数据映射
    x?: string;      // X轴/类别字段
    y?: string | string[]; // Y轴/数值字段（可以是多个）
    series?: string; // 系列字段
    size?: string;   // 大小映射字段（散点图等）
    color?: string;  // 颜色映射字段
  };
  options: Record<string, any>; // 图表特定选项
}
```

**主要特点**：
- 支持多种常见图表类型
- 灵活的数据字段映射机制
- 可扩展的选项设置
- 支持序列化和持久化

### 6.3 系统配置模型

系统配置模型用于管理全局系统设置，支持用户通过UI界面进行自定义。根据源码分析，系统配置模型定义如下：

```typescript
interface SystemConfig {
  fileWatching: {
    directories: string[];   // 监控的目录列表
    fileTypes: string[];     // 监控的文件类型列表
    watchInterval: number;   // 监控检查间隔（毫秒）
  };
  visualization: {
    defaultChartType: string; // 默认图表类型
    colorScheme: string;      // 配色方案
    autoRefresh: boolean;     // 是否自动刷新
    refreshInterval: number;  // 刷新间隔（毫秒）
  };
  ui: {
    theme: 'light' | 'dark' | 'auto'; // UI主题
    language: string;        // 界面语言
    tableSettings: {
      pageSize: number;      // 表格分页大小
      enableSearch: boolean; // 是否启用搜索
    };
  };
}
```

**主要特点**：
- 分模块管理不同功能的配置
- 支持文件监控的灵活配置
- 自定义可视化默认行为
- 界面主题和语言设置
- 表格显示的个性化设置

### 6.4 文件信息模型

文件信息模型用于表示文件系统中的文件和目录。根据源码分析，文件信息模型定义如下：

```typescript
interface FileInfo {
  id: string;           // 文件ID（Base64编码的文件路径）
  name: string;         // 文件/目录名称
  path: string;         // 文件/目录相对路径
  type: string;         // 文件类型（文件扩展名或"directory"）
  size: number;         // 文件大小（字节）
  lastModified: Date;   // 最后修改时间
  isDirectory: boolean; // 是否是目录
}
```

**主要特点**：
- 统一表示文件和目录
- 使用Base64编码的路径作为唯一标识
- 包含前端显示所需的所有属性
- 支持路径导航和文件选择

## 7. 部署指南

### 7.1 环境要求

本系统基于Node.js环境运行，部署前需要满足以下基本要求：

1. **软件要求**：
   - Node.js 14.x 或更高版本
   - npm 6.x 或更高版本（或yarn 1.22.x或更高版本）

2. **硬件建议**：
   - CPU: 双核或更高（推荐四核）
   - 内存: 最低2GB，推荐4GB或更高（处理大文件时更多）
   - 存储: 至少500MB可用空间（不包括表格文件存储空间）

3. **网络要求**：
   - 应用默认使用3000端口（前端）和3001端口（后端）
   - 建议有可用的防火墙配置，允许这些端口的访问

4. **操作系统**：
   - 跨平台支持：Windows、macOS、Linux

### 7.2 前端部署

#### 7.2.1 开发环境部署

1. **克隆或下载项目代码**：
   ```bash
   git clone [项目仓库URL] table-visualization
   cd table-visualization/frontend
   ```

2. **安装依赖**：
   ```bash
   npm install
   ```

3. **配置环境变量**：
   创建`.env.local`文件，配置API基础URL（如果需要）
   ```
   VITE_API_BASE_URL=http://localhost:3001/api
   ```

4. **启动开发服务器**：
   ```bash
   npm run dev
   ```
   开发服务器默认在http://localhost:3000启动

#### 7.2.2 生产环境部署

1. **构建前端项目**：
   ```bash
   npm run build
   ```
   构建结果将输出到`dist`目录

2. **部署构建产物**：
   可以使用Nginx、Apache等Web服务器部署构建产物，示例Nginx配置：
   ```nginx
   server {
     listen 80;
     server_name example.com;
     
     root /path/to/frontend/dist;
     index index.html;
     
     location / {
       try_files $uri $uri/ /index.html;
     }
     
     location /api {
       proxy_pass http://backend:3001;
       proxy_set_header Host $host;
       proxy_set_header X-Real-IP $remote_addr;
     }
     
     location /socket.io {
       proxy_pass http://backend:3001;
       proxy_http_version 1.1;
       proxy_set_header Upgrade $http_upgrade;
       proxy_set_header Connection "upgrade";
       proxy_set_header Host $host;
     }
   }
   ```

### 7.3 后端部署

#### 7.3.1 开发环境部署

1. **进入后端目录**：
   ```bash
   cd table-visualization/backend
   ```

2. **安装依赖**：
   ```bash
   npm install
   ```

3. **配置环境变量**：
   创建或编辑`.env`文件
   ```
   PORT=3001
   UPLOADS_DIR=./uploads
   DATA_DIR=./data
   CORS_ORIGIN=http://localhost:3000
   LOG_LEVEL=info
   ```

4. **启动开发服务器**：
   ```bash
   npm run dev
   ```
   这将使用ts-node-dev启动开发服务器，支持热重载

#### 7.3.2 生产环境部署

1. **构建后端项目**：
   ```bash
   npm run build
   ```
   构建结果将输出到`dist`目录

2. **生产环境配置**：
   创建生产环境的`.env`文件
   ```
   PORT=3001
   UPLOADS_DIR=/var/data/uploads
   DATA_DIR=/var/data/tables
   CORS_ORIGIN=https://example.com
   LOG_LEVEL=warn
   ```

3. **启动生产服务**：
   直接启动：
   ```bash
   node dist/index.js
   ```
   
   或使用PM2进行进程管理（推荐）：
   ```bash
   npm install -g pm2
   pm2 start dist/index.js --name "table-visualization"
   ```

4. **配置系统服务**：
   为确保服务器重启后自动启动，可以配置系统服务：
   
   对于systemd（Linux）：
   ```
   [Unit]
   Description=Table Visualization Service
   After=network.target
   
   [Service]
   Type=simple
   User=nodejs
   WorkingDirectory=/path/to/backend
   ExecStart=/usr/bin/node /path/to/backend/dist/index.js
   Restart=on-failure
   Environment=NODE_ENV=production
   
   [Install]
   WantedBy=multi-user.target
   ```

### 7.4 配置说明

系统配置存储在`backend/config/config.json`文件中，包含以下主要配置项：

```json
{
  "fileWatching": {
    "directories": ["./data", "./uploads"],
    "fileTypes": [".csv", ".xlsx", ".json"],
    "watchInterval": 5000
  },
  "visualization": {
    "defaultChartType": "bar",
    "colorScheme": "default",
    "autoRefresh": true,
    "refreshInterval": 30000
  },
  "ui": {
    "theme": "light",
    "language": "zh-CN",
    "tableSettings": {
      "pageSize": 50,
      "enableSearch": true
    }
  }
}
```

**配置项说明**：

1. **fileWatching**:
   - `directories`: 要监控的目录列表（相对或绝对路径）
   - `fileTypes`: 要监控的文件扩展名列表
   - `watchInterval`: 文件监控检查间隔（毫秒）

2. **visualization**:
   - `defaultChartType`: 默认图表类型
   - `colorScheme`: 默认配色方案
   - `autoRefresh`: 是否自动刷新图表
   - `refreshInterval`: 图表自动刷新间隔（毫秒）

3. **ui**:
   - `theme`: 界面主题（light/dark/auto）
   - `language`: 界面语言
   - `tableSettings`: 表格显示设置

配置文件的修改可以通过系统设置界面完成，无需手动编辑。

### 7.5 Docker部署

系统支持Docker容器化部署，可以使用以下步骤进行部署：

#### 7.5.1 使用Docker Compose部署

1. **创建docker-compose.yml文件**：
   ```yaml
   version: '3'
   
   services:
     frontend:
       build: ./frontend
       ports:
         - "3000:80"
       depends_on:
         - backend
       networks:
         - app-network
   
     backend:
       build: ./backend
       ports:
         - "3001:3001"
       environment:
         - PORT=3001
         - UPLOADS_DIR=/app/uploads
         - DATA_DIR=/app/data
         - CORS_ORIGIN=http://localhost:3000
         - LOG_LEVEL=info
       volumes:
         - ./data:/app/data
         - ./uploads:/app/uploads
       networks:
         - app-network
   
   networks:
     app-network:
       driver: bridge
   ```

2. **创建前端Dockerfile**：
   ```Dockerfile
   # 构建阶段
   FROM node:16 as build
   WORKDIR /app
   COPY package*.json ./
   RUN npm install
   COPY . .
   RUN npm run build
   
   # 生产阶段
   FROM nginx:alpine
   COPY --from=build /app/dist /usr/share/nginx/html
   COPY nginx.conf /etc/nginx/conf.d/default.conf
   EXPOSE 80
   CMD ["nginx", "-g", "daemon off;"]
   ```

3. **创建nginx.conf配置文件**：
   ```nginx
   server {
     listen 80;
     
     location / {
       root /usr/share/nginx/html;
       index index.html;
       try_files $uri $uri/ /index.html;
     }
     
     location /api {
       proxy_pass http://backend:3001;
       proxy_set_header Host $host;
       proxy_set_header X-Real-IP $remote_addr;
     }
     
     location /socket.io {
       proxy_pass http://backend:3001;
       proxy_http_version 1.1;
       proxy_set_header Upgrade $http_upgrade;
       proxy_set_header Connection "upgrade";
       proxy_set_header Host $host;
     }
   }
   ```

4. **创建后端Dockerfile**：
   ```Dockerfile
   FROM node:16
   WORKDIR /app
   COPY package*.json ./
   RUN npm install
   COPY . .
   RUN npm run build
   
   EXPOSE 3001
   
   CMD ["node", "dist/index.js"]
   ```

5. **启动容器**：
   ```bash
   docker-compose up -d
   ```

#### 7.5.2 使用单独的容器部署

如果要分别部署前端和后端，可以使用以下命令：

前端：
```bash
cd frontend
docker build -t table-visualization-frontend .
docker run -d -p 3000:80 --name frontend table-visualization-frontend
```

后端：
```bash
cd backend
docker build -t table-visualization-backend .
docker run -d -p 3001:3001 -v $(pwd)/data:/app/data -v $(pwd)/uploads:/app/uploads --name backend table-visualization-backend
```

## 8. 性能与扩展性

### 8.1 性能优化方案

系统在设计实现过程中采用了多种性能优化策略，确保在处理大量数据和高频操作时的响应速度和资源利用效率：

1. **表格数据处理优化**
   - **虚拟滚动**：前端表格组件实现虚拟滚动技术，只渲染可视区域的数据，大幅减少DOM节点数量
   - **数据分页**：支持服务端和客户端分页，避免一次性加载大量数据
   - **数据缓存**：前端对已加载的表格数据进行缓存，减少重复请求
   - **懒加载**：表格数据按需加载，提高初始加载速度

2. **文件解析优化**
   - **流式处理**：对大文件采用流式读取和解析，控制内存使用
   - **数据采样**：对超大文件先进行数据采样，推断数据类型和结构
   - **多线程处理**：利用Node.js的worker_threads处理CPU密集型解析任务
   - **解析结果缓存**：缓存文件解析结果，避免重复解析

3. **文件监控优化**
   - **防抖动机制**：使用Chokidar的awaitWriteFinish选项，避免文件写入过程中的多次触发
   - **智能过滤**：只监控指定类型的文件，减少事件处理
   - **批量处理**：对短时间内的多个变更事件进行批量处理

4. **前端优化**
   - **代码分割**：使用Vue Router的路由懒加载实现代码分割
   - **资源压缩**：生产构建过程中对JavaScript和CSS进行压缩
   - **Tree Shaking**：移除未使用的代码
   - **预渲染**：关键路径预渲染，提高首屏加载速度

5. **网络优化**
   - **API请求合并**：减少HTTP请求数量
   - **HTTP缓存**：合理使用Cache-Control头
   - **Gzip压缩**：对响应数据进行压缩
   - **持久化WebSocket**：维护长连接减少重连开销

### 8.2 扩展性设计

系统采用模块化设计和松耦合架构，便于功能扩展和定制，主要的扩展性设计包括：

1. **前端扩展性**
   - **组件化设计**：所有UI功能都基于可复用组件构建
   - **插件机制**：支持第三方组件和插件集成
   - **主题定制**：支持自定义主题和样式
   - **国际化**：内置i18n支持，可扩展多语言

2. **后端扩展性**
   - **中间件架构**：Express的中间件架构支持功能扩展
   - **模块化服务**：核心功能以服务形式组织，可独立扩展
   - **事件驱动**：基于事件的松耦合通信机制
   - **可插拔组件**：文件解析器、通知服务等均可替换

3. **功能扩展点**
   - **文件格式扩展**：可添加新的文件格式解析器
   - **图表类型扩展**：支持添加自定义图表类型
   - **数据处理扩展**：可增加数据转换和分析功能
   - **身份认证扩展**：预留认证和授权接口

4. **配置驱动设计**
   - **动态配置**：大部分系统行为可通过配置文件调整
   - **UI配置界面**：提供统一的配置管理界面
   - **配置持久化**：配置变更自动保存和应用

### 8.3 已知限制及解决方案

在当前版本中，系统存在一些已知限制，以及对应的解决或缓解方案：

1. **大文件处理限制**
   - **问题**：超大文件（>50MB）可能导致内存占用过高或解析缓慢
   - **解决方案**：
     - 实现文件分块加载和处理
     - 提供数据采样功能，只处理部分数据
     - 优化内存管理，及时释放不需要的数据
     - 考虑使用数据库作为中间存储

2. **并发处理限制**
   - **问题**：大量并发文件变更可能导致系统负载过高
   - **解决方案**：
     - 实现请求队列和限流机制
     - 增加负载均衡，分散处理压力
     - 优化事件处理逻辑，减少资源占用

3. **浏览器兼容性**
   - **问题**：部分高级功能在旧版浏览器上可能不可用
   - **解决方案**：
     - 使用Babel等工具进行代码转译
     - 实现功能降级方案
     - 明确记录最低浏览器版本要求

4. **安全性限制**
   - **问题**：当前版本缺乏完整的认证和授权机制
   - **解决方案**：
     - 计划添加JWT或OAuth2认证
     - 实现细粒度权限控制
     - 增加安全审计日志

5. **可视化复杂度限制**
   - **问题**：复杂的自定义可视化需求难以满足
   - **解决方案**：
     - 提供自定义可视化API
     - 支持导入外部可视化组件
     - 实现可视化模板系统

## 9. 安全性考虑

### 9.1 数据安全

系统处理各种表格数据，数据安全是重要考虑因素：

1. **数据传输安全**
   - 建议在生产环境中启用HTTPS
   - 敏感数据传输时进行加密
   - 使用安全的WebSocket连接（wss://）

2. **数据存储安全**
   - 敏感数据存储时考虑加密
   - 实施文件权限控制
   - 定期备份数据

3. **数据处理安全**
   - 避免在日志中记录敏感数据
   - 实施数据脱敏处理
   - 内存中的敏感数据使用完毕后及时清除

4. **数据隔离**
   - 不同用户的数据相互隔离
   - 采用最小权限原则
   - 防止未授权访问

### 9.2 访问控制

目前系统未实现完整的访问控制，以下是建议的访问控制实施方案：

1. **认证机制**
   - 实现用户认证系统（JWT/OAuth2）
   - 支持多因素认证
   - 会话管理和安全退出

2. **授权控制**
   - 基于角色的访问控制（RBAC）
   - 细粒度权限设计
   - 文件和目录级别的权限控制

3. **API安全**
   - 实施API密钥认证
   - 请求限流和防暴力破解
   - 输入验证和参数检查

4. **前端安全**
   - 防止跨站脚本攻击（XSS）
   - 防止跨站请求伪造（CSRF）
   - 安全的本地存储使用

### 9.3 安全最佳实践

系统在开发和部署过程中应遵循以下安全最佳实践：

1. **安全编码**
   - 遵循OWASP安全编码标准
   - 定期进行代码安全审查
   - 使用安全的第三方库

2. **安全配置**
   - 使用安全的默认配置
   - 移除不必要的功能和服务
   - 定期更新和补丁

3. **安全监控**
   - 实施日志监控和审计
   - 异常行为检测
   - 安全事件响应流程

4. **定期安全评估**
   - 安全漏洞扫描
   - 渗透测试
   - 安全合规检查

5. **安全文档**
   - 提供安全配置指南
   - 记录安全最佳实践
   - 安全响应计划



通过本文档的详细说明，可以充分理解系统的架构设计、API规范、数据模型和部署方法，顺利完成系统的实施和维护工作。
